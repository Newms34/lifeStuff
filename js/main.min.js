/**
 * bootbox.js [v4.4.0]
 *
 * http://bootboxjs.com/license.txt
 */

// @see https://github.com/makeusabrew/bootbox/issues/180
// @see https://github.com/makeusabrew/bootbox/issues/186
(function (root, factory) {

  "use strict";
  if (typeof define === "function" && define.amd) {
    // AMD. Register as an anonymous module.
    define(["jquery"], factory);
  } else if (typeof exports === "object") {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory(require("jquery"));
  } else {
    // Browser globals (root is window)
    root.bootbox = factory(root.jQuery);
  }

}(this, function init($, undefined) {

  "use strict";

  // the base DOM structure needed to create a modal
  var templates = {
    dialog:
      "<div class='bootbox modal' tabindex='-1' role='dialog'>" +
        "<div class='modal-dialog'>" +
          "<div class='modal-content'>" +
            "<div class='modal-body'><div class='bootbox-body'></div></div>" +
          "</div>" +
        "</div>" +
      "</div>",
    header:
      "<div class='modal-header'>" +
        "<h4 class='modal-title'></h4>" +
      "</div>",
    footer:
      "<div class='modal-footer'></div>",
    closeButton:
      "<button type='button' class='bootbox-close-button close' data-dismiss='modal' aria-hidden='true'>&times;</button>",
    form:
      "<form class='bootbox-form'></form>",
    inputs: {
      text:
        "<input class='bootbox-input bootbox-input-text form-control' autocomplete=off type=text />",
      textarea:
        "<textarea class='bootbox-input bootbox-input-textarea form-control'></textarea>",
      email:
        "<input class='bootbox-input bootbox-input-email form-control' autocomplete='off' type='email' />",
      select:
        "<select class='bootbox-input bootbox-input-select form-control'></select>",
      checkbox:
        "<div class='checkbox'><label><input class='bootbox-input bootbox-input-checkbox' type='checkbox' /></label></div>",
      date:
        "<input class='bootbox-input bootbox-input-date form-control' autocomplete=off type='date' />",
      time:
        "<input class='bootbox-input bootbox-input-time form-control' autocomplete=off type='time' />",
      number:
        "<input class='bootbox-input bootbox-input-number form-control' autocomplete=off type='number' />",
      password:
        "<input class='bootbox-input bootbox-input-password form-control' autocomplete='off' type='password' />"
    }
  };

  var defaults = {
    // default language
    locale: "en",
    // show backdrop or not. Default to static so user has to interact with dialog
    backdrop: "static",
    // animate the modal in/out
    animate: true,
    // additional class string applied to the top level dialog
    className: null,
    // whether or not to include a close button
    closeButton: true,
    // show the dialog immediately by default
    show: true,
    // dialog container
    container: "body"
  };

  // our public object; augmented after our private API
  var exports = {};

  /**
   * @private
   */
  function _t(key) {
    var locale = locales[defaults.locale];
    return locale ? locale[key] : locales.en[key];
  }

  function processCallback(e, dialog, callback) {
    e.stopPropagation();
    e.preventDefault();

    // by default we assume a callback will get rid of the dialog,
    // although it is given the opportunity to override this

    // so, if the callback can be invoked and it *explicitly returns false*
    // then we'll set a flag to keep the dialog active...
    var preserveDialog = $.isFunction(callback) && callback.call(dialog, e) === false;

    // ... otherwise we'll bin it
    if (!preserveDialog) {
      dialog.modal("hide");
    }
  }

  function getKeyLength(obj) {
    // @TODO defer to Object.keys(x).length if available?
    var k, t = 0;
    for (k in obj) {
      t ++;
    }
    return t;
  }

  function each(collection, iterator) {
    var index = 0;
    $.each(collection, function(key, value) {
      iterator(key, value, index++);
    });
  }

  function sanitize(options) {
    var buttons;
    var total;

    if (typeof options !== "object") {
      throw new Error("Please supply an object of options");
    }

    if (!options.message) {
      throw new Error("Please specify a message");
    }

    // make sure any supplied options take precedence over defaults
    options = $.extend({}, defaults, options);

    if (!options.buttons) {
      options.buttons = {};
    }

    buttons = options.buttons;

    total = getKeyLength(buttons);

    each(buttons, function(key, button, index) {

      if ($.isFunction(button)) {
        // short form, assume value is our callback. Since button
        // isn't an object it isn't a reference either so re-assign it
        button = buttons[key] = {
          callback: button
        };
      }

      // before any further checks make sure by now button is the correct type
      if ($.type(button) !== "object") {
        throw new Error("button with key " + key + " must be an object");
      }

      if (!button.label) {
        // the lack of an explicit label means we'll assume the key is good enough
        button.label = key;
      }

      if (!button.className) {
        if (total <= 2 && index === total-1) {
          // always add a primary to the main option in a two-button dialog
          button.className = "btn-primary";
        } else {
          button.className = "btn-default";
        }
      }
    });

    return options;
  }

  /**
   * map a flexible set of arguments into a single returned object
   * if args.length is already one just return it, otherwise
   * use the properties argument to map the unnamed args to
   * object properties
   * so in the latter case:
   * mapArguments(["foo", $.noop], ["message", "callback"])
   * -> { message: "foo", callback: $.noop }
   */
  function mapArguments(args, properties) {
    var argn = args.length;
    var options = {};

    if (argn < 1 || argn > 2) {
      throw new Error("Invalid argument length");
    }

    if (argn === 2 || typeof args[0] === "string") {
      options[properties[0]] = args[0];
      options[properties[1]] = args[1];
    } else {
      options = args[0];
    }

    return options;
  }

  /**
   * merge a set of default dialog options with user supplied arguments
   */
  function mergeArguments(defaults, args, properties) {
    return $.extend(
      // deep merge
      true,
      // ensure the target is an empty, unreferenced object
      {},
      // the base options object for this type of dialog (often just buttons)
      defaults,
      // args could be an object or array; if it's an array properties will
      // map it to a proper options object
      mapArguments(
        args,
        properties
      )
    );
  }

  /**
   * this entry-level method makes heavy use of composition to take a simple
   * range of inputs and return valid options suitable for passing to bootbox.dialog
   */
  function mergeDialogOptions(className, labels, properties, args) {
    //  build up a base set of dialog properties
    var baseOptions = {
      className: "bootbox-" + className,
      buttons: createLabels.apply(null, labels)
    };

    // ensure the buttons properties generated, *after* merging
    // with user args are still valid against the supplied labels
    return validateButtons(
      // merge the generated base properties with user supplied arguments
      mergeArguments(
        baseOptions,
        args,
        // if args.length > 1, properties specify how each arg maps to an object key
        properties
      ),
      labels
    );
  }

  /**
   * from a given list of arguments return a suitable object of button labels
   * all this does is normalise the given labels and translate them where possible
   * e.g. "ok", "confirm" -> { ok: "OK, cancel: "Annuleren" }
   */
  function createLabels() {
    var buttons = {};

    for (var i = 0, j = arguments.length; i < j; i++) {
      var argument = arguments[i];
      var key = argument.toLowerCase();
      var value = argument.toUpperCase();

      buttons[key] = {
        label: _t(value)
      };
    }

    return buttons;
  }

  function validateButtons(options, buttons) {
    var allowedButtons = {};
    each(buttons, function(key, value) {
      allowedButtons[value] = true;
    });

    each(options.buttons, function(key) {
      if (allowedButtons[key] === undefined) {
        throw new Error("button key " + key + " is not allowed (options are " + buttons.join("\n") + ")");
      }
    });

    return options;
  }

  exports.alert = function() {
    var options;

    options = mergeDialogOptions("alert", ["ok"], ["message", "callback"], arguments);

    if (options.callback && !$.isFunction(options.callback)) {
      throw new Error("alert requires callback property to be a function when provided");
    }

    /**
     * overrides
     */
    options.buttons.ok.callback = options.onEscape = function() {
      if ($.isFunction(options.callback)) {
        return options.callback.call(this);
      }
      return true;
    };

    return exports.dialog(options);
  };

  exports.confirm = function() {
    var options;

    options = mergeDialogOptions("confirm", ["cancel", "confirm"], ["message", "callback"], arguments);

    /**
     * overrides; undo anything the user tried to set they shouldn't have
     */
    options.buttons.cancel.callback = options.onEscape = function() {
      return options.callback.call(this, false);
    };

    options.buttons.confirm.callback = function() {
      return options.callback.call(this, true);
    };

    // confirm specific validation
    if (!$.isFunction(options.callback)) {
      throw new Error("confirm requires a callback");
    }

    return exports.dialog(options);
  };

  exports.prompt = function() {
    var options;
    var defaults;
    var dialog;
    var form;
    var input;
    var shouldShow;
    var inputOptions;

    // we have to create our form first otherwise
    // its value is undefined when gearing up our options
    // @TODO this could be solved by allowing message to
    // be a function instead...
    form = $(templates.form);

    // prompt defaults are more complex than others in that
    // users can override more defaults
    // @TODO I don't like that prompt has to do a lot of heavy
    // lifting which mergeDialogOptions can *almost* support already
    // just because of 'value' and 'inputType' - can we refactor?
    defaults = {
      className: "bootbox-prompt",
      buttons: createLabels("cancel", "confirm"),
      value: "",
      inputType: "text"
    };

    options = validateButtons(
      mergeArguments(defaults, arguments, ["title", "callback"]),
      ["cancel", "confirm"]
    );

    // capture the user's show value; we always set this to false before
    // spawning the dialog to give us a chance to attach some handlers to
    // it, but we need to make sure we respect a preference not to show it
    shouldShow = (options.show === undefined) ? true : options.show;

    /**
     * overrides; undo anything the user tried to set they shouldn't have
     */
    options.message = form;

    options.buttons.cancel.callback = options.onEscape = function() {
      return options.callback.call(this, null);
    };

    options.buttons.confirm.callback = function() {
      var value;

      switch (options.inputType) {
        case "text":
        case "textarea":
        case "email":
        case "select":
        case "date":
        case "time":
        case "number":
        case "password":
          value = input.val();
          break;

        case "checkbox":
          var checkedItems = input.find("input:checked");

          // we assume that checkboxes are always multiple,
          // hence we default to an empty array
          value = [];

          each(checkedItems, function(_, item) {
            value.push($(item).val());
          });
          break;
      }

      return options.callback.call(this, value);
    };

    options.show = false;

    // prompt specific validation
    if (!options.title) {
      throw new Error("prompt requires a title");
    }

    if (!$.isFunction(options.callback)) {
      throw new Error("prompt requires a callback");
    }

    if (!templates.inputs[options.inputType]) {
      throw new Error("invalid prompt type");
    }

    // create the input based on the supplied type
    input = $(templates.inputs[options.inputType]);

    switch (options.inputType) {
      case "text":
      case "textarea":
      case "email":
      case "date":
      case "time":
      case "number":
      case "password":
        input.val(options.value);
        break;

      case "select":
        var groups = {};
        inputOptions = options.inputOptions || [];

        if (!$.isArray(inputOptions)) {
          throw new Error("Please pass an array of input options");
        }

        if (!inputOptions.length) {
          throw new Error("prompt with select requires options");
        }

        each(inputOptions, function(_, option) {

          // assume the element to attach to is the input...
          var elem = input;

          if (option.value === undefined || option.text === undefined) {
            throw new Error("given options in wrong format");
          }

          // ... but override that element if this option sits in a group

          if (option.group) {
            // initialise group if necessary
            if (!groups[option.group]) {
              groups[option.group] = $("<optgroup/>").attr("label", option.group);
            }

            elem = groups[option.group];
          }

          elem.append("<option value='" + option.value + "'>" + option.text + "</option>");
        });

        each(groups, function(_, group) {
          input.append(group);
        });

        // safe to set a select's value as per a normal input
        input.val(options.value);
        break;

      case "checkbox":
        var values   = $.isArray(options.value) ? options.value : [options.value];
        inputOptions = options.inputOptions || [];

        if (!inputOptions.length) {
          throw new Error("prompt with checkbox requires options");
        }

        if (!inputOptions[0].value || !inputOptions[0].text) {
          throw new Error("given options in wrong format");
        }

        // checkboxes have to nest within a containing element, so
        // they break the rules a bit and we end up re-assigning
        // our 'input' element to this container instead
        input = $("<div/>");

        each(inputOptions, function(_, option) {
          var checkbox = $(templates.inputs[options.inputType]);

          checkbox.find("input").attr("value", option.value);
          checkbox.find("label").append(option.text);

          // we've ensured values is an array so we can always iterate over it
          each(values, function(_, value) {
            if (value === option.value) {
              checkbox.find("input").prop("checked", true);
            }
          });

          input.append(checkbox);
        });
        break;
    }

    // @TODO provide an attributes option instead
    // and simply map that as keys: vals
    if (options.placeholder) {
      input.attr("placeholder", options.placeholder);
    }

    if (options.pattern) {
      input.attr("pattern", options.pattern);
    }

    if (options.maxlength) {
      input.attr("maxlength", options.maxlength);
    }

    // now place it in our form
    form.append(input);

    form.on("submit", function(e) {
      e.preventDefault();
      // Fix for SammyJS (or similar JS routing library) hijacking the form post.
      e.stopPropagation();
      // @TODO can we actually click *the* button object instead?
      // e.g. buttons.confirm.click() or similar
      dialog.find(".btn-primary").click();
    });

    dialog = exports.dialog(options);

    // clear the existing handler focusing the submit button...
    dialog.off("shown.bs.modal");

    // ...and replace it with one focusing our input, if possible
    dialog.on("shown.bs.modal", function() {
      // need the closure here since input isn't
      // an object otherwise
      input.focus();
    });

    if (shouldShow === true) {
      dialog.modal("show");
    }

    return dialog;
  };

  exports.dialog = function(options) {
    options = sanitize(options);

    var dialog = $(templates.dialog);
    var innerDialog = dialog.find(".modal-dialog");
    var body = dialog.find(".modal-body");
    var buttons = options.buttons;
    var buttonStr = "";
    var callbacks = {
      onEscape: options.onEscape
    };

    if ($.fn.modal === undefined) {
      throw new Error(
        "$.fn.modal is not defined; please double check you have included " +
        "the Bootstrap JavaScript library. See http://getbootstrap.com/javascript/ " +
        "for more details."
      );
    }

    each(buttons, function(key, button) {

      // @TODO I don't like this string appending to itself; bit dirty. Needs reworking
      // can we just build up button elements instead? slower but neater. Then button
      // can just become a template too
      buttonStr += "<button data-bb-handler='" + key + "' type='button' class='btn " + button.className + "'>" + button.label + "</button>";
      callbacks[key] = button.callback;
    });

    body.find(".bootbox-body").html(options.message);

    if (options.animate === true) {
      dialog.addClass("fade");
    }

    if (options.className) {
      dialog.addClass(options.className);
    }

    if (options.size === "large") {
      innerDialog.addClass("modal-lg");
    } else if (options.size === "small") {
      innerDialog.addClass("modal-sm");
    }

    if (options.title) {
      body.before(templates.header);
    }

    if (options.closeButton) {
      var closeButton = $(templates.closeButton);

      if (options.title) {
        dialog.find(".modal-header").prepend(closeButton);
      } else {
        closeButton.css("margin-top", "-10px").prependTo(body);
      }
    }

    if (options.title) {
      dialog.find(".modal-title").html(options.title);
    }

    if (buttonStr.length) {
      body.after(templates.footer);
      dialog.find(".modal-footer").html(buttonStr);
    }


    /**
     * Bootstrap event listeners; used handle extra
     * setup & teardown required after the underlying
     * modal has performed certain actions
     */

    dialog.on("hidden.bs.modal", function(e) {
      // ensure we don't accidentally intercept hidden events triggered
      // by children of the current dialog. We shouldn't anymore now BS
      // namespaces its events; but still worth doing
      if (e.target === this) {
        dialog.remove();
      }
    });

    /*
    dialog.on("show.bs.modal", function() {
      // sadly this doesn't work; show is called *just* before
      // the backdrop is added so we'd need a setTimeout hack or
      // otherwise... leaving in as would be nice
      if (options.backdrop) {
        dialog.next(".modal-backdrop").addClass("bootbox-backdrop");
      }
    });
    */

    dialog.on("shown.bs.modal", function() {
      dialog.find(".btn-primary:first").focus();
    });

    /**
     * Bootbox event listeners; experimental and may not last
     * just an attempt to decouple some behaviours from their
     * respective triggers
     */

    if (options.backdrop !== "static") {
      // A boolean true/false according to the Bootstrap docs
      // should show a dialog the user can dismiss by clicking on
      // the background.
      // We always only ever pass static/false to the actual
      // $.modal function because with `true` we can't trap
      // this event (the .modal-backdrop swallows it)
      // However, we still want to sort of respect true
      // and invoke the escape mechanism instead
      dialog.on("click.dismiss.bs.modal", function(e) {
        // @NOTE: the target varies in >= 3.3.x releases since the modal backdrop
        // moved *inside* the outer dialog rather than *alongside* it
        if (dialog.children(".modal-backdrop").length) {
          e.currentTarget = dialog.children(".modal-backdrop").get(0);
        }

        if (e.target !== e.currentTarget) {
          return;
        }

        dialog.trigger("escape.close.bb");
      });
    }

    dialog.on("escape.close.bb", function(e) {
      if (callbacks.onEscape) {
        processCallback(e, dialog, callbacks.onEscape);
      }
    });

    /**
     * Standard jQuery event listeners; used to handle user
     * interaction with our dialog
     */

    dialog.on("click", ".modal-footer button", function(e) {
      var callbackKey = $(this).data("bb-handler");

      processCallback(e, dialog, callbacks[callbackKey]);
    });

    dialog.on("click", ".bootbox-close-button", function(e) {
      // onEscape might be falsy but that's fine; the fact is
      // if the user has managed to click the close button we
      // have to close the dialog, callback or not
      processCallback(e, dialog, callbacks.onEscape);
    });

    dialog.on("keyup", function(e) {
      if (e.which === 27) {
        dialog.trigger("escape.close.bb");
      }
    });

    // the remainder of this method simply deals with adding our
    // dialogent to the DOM, augmenting it with Bootstrap's modal
    // functionality and then giving the resulting object back
    // to our caller

    $(options.container).append(dialog);

    dialog.modal({
      backdrop: options.backdrop ? "static": false,
      keyboard: false,
      show: false
    });

    if (options.show) {
      dialog.modal("show");
    }

    // @TODO should we return the raw element here or should
    // we wrap it in an object on which we can expose some neater
    // methods, e.g. var d = bootbox.alert(); d.hide(); instead
    // of d.modal("hide");

   /*
    function BBDialog(elem) {
      this.elem = elem;
    }

    BBDialog.prototype = {
      hide: function() {
        return this.elem.modal("hide");
      },
      show: function() {
        return this.elem.modal("show");
      }
    };
    */

    return dialog;

  };

  exports.setDefaults = function() {
    var values = {};

    if (arguments.length === 2) {
      // allow passing of single key/value...
      values[arguments[0]] = arguments[1];
    } else {
      // ... and as an object too
      values = arguments[0];
    }

    $.extend(defaults, values);
  };

  exports.hideAll = function() {
    $(".bootbox").modal("hide");

    return exports;
  };


  /**
   * standard locales. Please add more according to ISO 639-1 standard. Multiple language variants are
   * unlikely to be required. If this gets too large it can be split out into separate JS files.
   */
  var locales = {
    bg_BG : {
      OK      : "Ок",
      CANCEL  : "Отказ",
      CONFIRM : "Потвърждавам"
    },
    br : {
      OK      : "OK",
      CANCEL  : "Cancelar",
      CONFIRM : "Sim"
    },
    cs : {
      OK      : "OK",
      CANCEL  : "Zrušit",
      CONFIRM : "Potvrdit"
    },
    da : {
      OK      : "OK",
      CANCEL  : "Annuller",
      CONFIRM : "Accepter"
    },
    de : {
      OK      : "OK",
      CANCEL  : "Abbrechen",
      CONFIRM : "Akzeptieren"
    },
    el : {
      OK      : "Εντάξει",
      CANCEL  : "Ακύρωση",
      CONFIRM : "Επιβεβαίωση"
    },
    en : {
      OK      : "OK",
      CANCEL  : "Cancel",
      CONFIRM : "OK"
    },
    es : {
      OK      : "OK",
      CANCEL  : "Cancelar",
      CONFIRM : "Aceptar"
    },
    et : {
      OK      : "OK",
      CANCEL  : "Katkesta",
      CONFIRM : "OK"
    },
    fa : {
      OK      : "قبول",
      CANCEL  : "لغو",
      CONFIRM : "تایید"
    },
    fi : {
      OK      : "OK",
      CANCEL  : "Peruuta",
      CONFIRM : "OK"
    },
    fr : {
      OK      : "OK",
      CANCEL  : "Annuler",
      CONFIRM : "D'accord"
    },
    he : {
      OK      : "אישור",
      CANCEL  : "ביטול",
      CONFIRM : "אישור"
    },
    hu : {
      OK      : "OK",
      CANCEL  : "Mégsem",
      CONFIRM : "Megerősít"
    },
    hr : {
      OK      : "OK",
      CANCEL  : "Odustani",
      CONFIRM : "Potvrdi"
    },
    id : {
      OK      : "OK",
      CANCEL  : "Batal",
      CONFIRM : "OK"
    },
    it : {
      OK      : "OK",
      CANCEL  : "Annulla",
      CONFIRM : "Conferma"
    },
    ja : {
      OK      : "OK",
      CANCEL  : "キャンセル",
      CONFIRM : "確認"
    },
    lt : {
      OK      : "Gerai",
      CANCEL  : "Atšaukti",
      CONFIRM : "Patvirtinti"
    },
    lv : {
      OK      : "Labi",
      CANCEL  : "Atcelt",
      CONFIRM : "Apstiprināt"
    },
    nl : {
      OK      : "OK",
      CANCEL  : "Annuleren",
      CONFIRM : "Accepteren"
    },
    no : {
      OK      : "OK",
      CANCEL  : "Avbryt",
      CONFIRM : "OK"
    },
    pl : {
      OK      : "OK",
      CANCEL  : "Anuluj",
      CONFIRM : "Potwierdź"
    },
    pt : {
      OK      : "OK",
      CANCEL  : "Cancelar",
      CONFIRM : "Confirmar"
    },
    ru : {
      OK      : "OK",
      CANCEL  : "Отмена",
      CONFIRM : "Применить"
    },
    sq : {
      OK : "OK",
      CANCEL : "Anulo",
      CONFIRM : "Prano"
    },
    sv : {
      OK      : "OK",
      CANCEL  : "Avbryt",
      CONFIRM : "OK"
    },
    th : {
      OK      : "ตกลง",
      CANCEL  : "ยกเลิก",
      CONFIRM : "ยืนยัน"
    },
    tr : {
      OK      : "Tamam",
      CANCEL  : "İptal",
      CONFIRM : "Onayla"
    },
    zh_CN : {
      OK      : "OK",
      CANCEL  : "取消",
      CONFIRM : "确认"
    },
    zh_TW : {
      OK      : "OK",
      CANCEL  : "取消",
      CONFIRM : "確認"
    }
  };

  exports.addLocale = function(name, values) {
    $.each(["OK", "CANCEL", "CONFIRM"], function(_, v) {
      if (!values[v]) {
        throw new Error("Please supply a translation for '" + v + "'");
      }
    });

    locales[name] = {
      OK: values.OK,
      CANCEL: values.CANCEL,
      CONFIRM: values.CONFIRM
    };

    return exports;
  };

  exports.removeLocale = function(name) {
    delete locales[name];

    return exports;
  };

  exports.setLocale = function(name) {
    return exports.setDefaults("locale", name);
  };

  exports.init = function(_$) {
    return init(_$ || $);
  };

  return exports;
}));

var fl = {
	'bird':['mouse','hamster','rabbit','herb','deciduous','evergreen','chestnut','corn','rice','cactus','flower','cherry','bug','ant','ladybug','spider'],//may wanna split this up later depending on diet
    'mouse': ['chestnut', 'corn', 'rice', 'evergreen', 'deciduous', 'herb', 'palm', 'cactus', 'flower', 'cherry', 'sunflower', 'blossom', 'bug', 'ant', 'ladybug', 'spider', 'maple'],
    'cow': ['grass', 'blossom', 'tulip', 'whiteflower', 'flower', 'herb'],
    'tiger': ['cow', 'monkey', 'mouse', 'dog', 'pig', 'rabbit', 'cat', 'horse', 'hamster', 'wolf','bird'],
    'monkey': ['corn', 'rice', 'deciduous', 'herb', 'palm', 'flower', 'cherry', 'mouse', 'hamster', 'frog', 'pig', 'bug', 'ant','bird'],
    'dog': ['hamster', 'mouse', 'pig', 'frog', 'rabbit', 'cat','bird'],
    'pig': ['bug', 'ant', 'bee', 'grass', 'cherry', 'deciduous', 'spider', 'mouse', 'herb', 'rice', 'corn', 'blossom', 'chestnut'],
    'frog': ['bug', 'ant', 'bee', 'ladybug', 'spider'],
    'rabbit': ['grass', 'herb', 'cherry', 'sunflower', 'deciduous', 'herbivore', 'chestnut', 'maple', 'whiteflower', 'flower'],
    'cat': ['mouse', 'hamster', 'pig','bird'],
    'dragon': ['mouse', 'cow', 'tiger', 'monkey', 'dog', 'pig', 'frog', 'rabbit', 'cat', 'horse', 'hamster', 'wolf', 'bear', 'panda','bird'],
    'horse': ['grass', 'herb', 'deciduous', 'evergreen', 'tulip', 'blossom', 'whiteflower', 'flower', 'corn', 'rice', 'palm'],
    'hamster': ['chestnut', 'blossom', 'maple', 'herb', 'palm', 'deciduous', 'flower'],
    'wolf': ['rabbit','mouse','hamster','horse','cow','pig','cat','bird'],
    'bear': ['rabbit','mouse','hamster','horse','pig','cow','cat','dog','cat','chestnut','corn','cherry','herb','rice','flower','ant'],
    'panda': ['grass'],//interesting fact: bamboo is a grass!
    'bug': ['chestnut','deciduous','cherry','corn','rice','ant','flower','grass','herb','bee','spider','ladybug'],
    'ant': ['bug','cherry','corn','rice','herb','bee','spider','ladybug','chestnut'],
    'bee': ['flower','whiteflower','herb','deciduous','evergreen'],
    'ladybug': ['ant','bug','spider'],
    'spider': ['ant','bug','ladybug','bee']
};
//note on spawn chance:
//For now, it's irrelevant, but eventually it'll control the distribution of orgs at starter
var orgStats = {
	'bird': {
        img: '\uD83D\uDC26',
        spawnChance:1,
        gestation:21,
        timeToMature:104,
        type: 'omni'
    },
    'mouse': {
        img: '\uD83D\uDC01',
        spawnChance:1,
        gestation:20,
        timeToMature:2,
        type: 'omni'
    },
    'cow': {
        img: '\uD83D\uDC04',
        spawnChance:1,
        gestation:284,
        timeToMature:676,
        type: 'herbi'
    },
    'tiger': {
        img: '\uD83D\uDC05',
        spawnChance:1,
        gestation:102,
        timeToMature:156,
        type: 'pred'
    },
    'monkey': {
        img: '\uD83D\uDC12',
        spawnChance:1,
        gestation:175,
        timeToMature:156,
        type: 'omni'
    },
    'dog': {
        img: '\uD83D\uDC15',
        spawnChance:1,
        gestation:63,
        timeToMature:104,
        type: 'pred'
    },
    'pig': {
        img: '\uD83D\uDC16',
        spawnChance:1,
        gestation:115,
        timeToMature:30,
        type: 'omni'
    },
    'frog': {
        img: '\uD83D\uDC38',
        spawnChance:1,
        gestation:21,
        timeToMature:52,
        type: 'pred'
    },
    'rabbit': {
        img: '\uD83D\uDC07',
        spawnChance:1,
        gestation:30,
        timeToMature:25,
        type: 'herbi'
    },
    'cat': {
        img: '\uD83D\uDC08',
        spawnChance:1,
        gestation:50,
        timeToMature:40,
        type: 'pred'
    },
    'dragon': {
        img: '\uD83D\uDC09',
        spawnChance:1,
        gestation:390,
        timeToMature:780,
        type: 'pred'
    },
    'horse': {
        img: '\uD83D\uDC0E',
        spawnChance:1,
        gestation:340,
        timeToMature:65,
        type: 'herbi'
    },
    'hamster': {
        img: '\uD83D\uDC39',
        spawnChance:1,
        gestation:22,
        timeToMature:5,
        type: 'omni'
    },
    'wolf': {
        img: '\uD83D\uDC3A',
        spawnChance:1,
        gestation:68,
        timeToMature:156,
        type: 'pred'
    },
    'bear': {
        img: '\uD83D\uDC3B',
        spawnChance:1,
        gestation:215,
        timeToMature:208,
        type: 'omni'
    },
    'panda': {
        img: '\uD83D\uDC3C',
        spawnChance:1,
        gestation:127,
        timeToMature:312,
        type: 'herbi'
    },
    'bug': {
        img: '\uD83D\uDC1B',
        spawnChance:1,
        gestation:10,
        timeToMature:5,
        type: 'omni'
    },
    'ant': {
        img: '\uD83D\uDC1C',
        spawnChance:1,
        gestation:10,
        timeToMature:5,
        type: 'omni'
    },
    'bee': {
        img: '\uD83D\uDC1D',
        spawnChance:1,
        gestation:10,
        timeToMature:5,
        type: 'herbi'
    },
    'ladybug': {
        img: '\uD83D\uDC1E',
        spawnChance:1,
        gestation:15,
        timeToMature:5,
        type: 'pred'
    },
    'spider': {
        img: '\uD83D\uDD77',
        spawnChance:1,
        gestation:21,
        timeToMature:5,
        type: 'pred'
    },
    'chestnut': {
        img: '\uD83C\uDF30',
        spawnChance:1,
        gestation:10,
        timeToMature:208,
        type: 'prod'
    },
    'corn': {
        img: '\uD83C\uDF3D',
        spawnChance:1,
        gestation:10,
        timeToMature:11,
        type: 'prod'
    },
    'rice': {
        img: '\uD83C\uDF3E',
        spawnChance:1,
        gestation:10,
        timeToMature:16,
        type: 'prod'
    },
    'herb': {
        img: '\uD83C\uDF3F',
        spawnChance:1,
        gestation:10,
        timeToMature:10,
        type: 'prod'
    },
    'maple': {
        img: '\uD83C\uDF41',
        spawnChance:1,
        gestation:10,
        timeToMature:208,
        type: 'prod'
    },
    'cactus': {
        img: '\uD83C\uDF35',
        spawnChance:1,
        gestation:10,
        timeToMature:208,
        type: 'prod'
    },
    'evergreen': {
        img: '\uD83C\uDF32',
        spawnChance:1,
        gestation:10,
        timeToMature:208,
        type: 'prod'
    },
    'deciduous': {
        img: '\uD83C\uDF33',
        spawnChance:1,
        gestation:10,
        timeToMature:208,
        type: 'prod'
    },
    'palm': {
        img: '\uD83C\uDF34',
        spawnChance:1,
        gestation:10,
        timeToMature:364,
        type: 'prod'
    },
    'flower': {
        img: '\u2698',
        spawnChance:1,
        gestation:10,
        timeToMature:7,
        type: 'prod'
    },
    'whiteflower': {
        img: '\u2740',
        spawnChance:1,
        gestation:10,
        timeToMature:7,
        type: 'prod'
    },
    'tulip': {
        img: '\uD83C\uDF37',
        spawnChance:1,
        gestation:10,
        timeToMature:7,
        type: 'prod'
    },
    'cherry': {
        img: '\uD83C\uDF52',
        spawnChance:1,
        gestation:10,
        timeToMature:104,
        type: 'prod'
    },
    'sunflower': {
        img: '\uD83C\uDF3B',
        spawnChance:1,
        gestation:10,
        timeToMature:7,
        type: 'prod'
    },
    'blossom': {
        img: '\uD83C\uDF3C',
        spawnChance:1,
        gestation:10,
        timeToMature:7,
        type: 'prod'
    },
    'grass': {
        img: '|',
        spawnChance:1,
        gestation:10,
        timeToMature:2,
        type: 'prod'
    }
};
// NOTE: dragon times are based on similar sized animals. Rhinos and Whales all seem to have gestation periods in the range of 14-19 months. However, Dinosaurs are known (based on bone morphology) to have particularly fast growth rates. I'm merely extending this into the egg phase. Nevertheless, we're talking about a large animal, so it has the largest gestation period
var testPics = function(){
	var names = Object.keys(orgStats);
	for (var n in orgStats){
		console.log(n,orgStats[n].img.replace(/s/g,'\\'));
	}
};
/*ORGS:
    mouse
    cow
    tiger
    monkey
    dog
    pig
    frog
    rabbit
    cat
    dragon
    horse
    hamster
    wolf
    bear
    panda
    bug
    ant
    bee
    ladybug
    spider
    chestnut
    corn
    rice
    herb
    maple
    cactus
    evergreen
    deciduous
    palm
    flower
    whiteflower
    tulip
    cherry
    sunflower
    blossom
    grass (ꔖ)
    */

//TO DO:
//implement species (or at least trophic levels)!
/*PLAN:
Each organism will have:
x: x position
y: y position
z: z position
dx,dy,dz: movement in each direction
hp: current health
type: carnivore, omnivore, herbivore, producer (carni, omni, herbi, prod)
spec: species
eats: [array], except for plants
targ: current target
sex: gender
mate: function, takes targ if male or just sets 'receptive' if female
pred: function, attack target, attempt to kill. Onkill, gain all target's HP up to max of this org
fight: function, for inter/intraspecific non-predation-based competition. if target is same species, much lower chance to kill
isDef: number. If target is defended, preds have much lower chance to kill (and higher chance to die themselves)
matureTime: When young creature is created, it takes time before it can use any of the fns above.
mode: pred, mate, none, plant

WHAT NEEDS TO HAPPEN EACH ROUND:
1: kill off orgs with hp==0
2: change mode of orgs that have attempted a mating or predation or fight (i.e., that have mode==none) AND coolDown==0 AND matureTime==0;
    a: if matureTime and/or coolDown > 0, subtract 1
3: pick new relevant target
4: add 1 to hunger, 1 to lastMate for all orgs
    a: if hunger or lastMate>100, dont add 1. If hunger==100, subtract 1 from HP
5: check position of target and adjust org.vel to head towards targ
6: check boundaries and reverse if @ boundary.
7: if @ target and pred, pred fn.
8: if @ target and mate, mate fn.; produce babeh if successful.
9: if @ target and wander, fight fn.

MAY NEED TO TIME FIRST ROUND FOR SPEED!
*/
//Params
var maxNum = 100;
var orgs = [],
    w = $(window).width() - 10,
    h = $(window).height() - 10,
    d = w,
    timeDelta,
    itNum = 0; //all orgs

//constructor
var orgConst = function(x, y, z, spec, type, sex) {
    this.pos = {
        x: x,
        y: type == 'prod' ? h : y,
        z:  z
    };
    this.vel = {
        dx: 1,
        dy: type == 'prod' ? 0 : 1,
        dz:1
    };
    this.hp = 300;
    this.id = Math.floor(Math.random() * 9999999999999).toString(32); //generate a random id for this org for tracking
    this.type = type;
    this.spec = spec;
    this.eats = fl[this.spec];
    this.sex = sex; //1 = male, 2 = female
    this.vis = 10; //may make this dynamic later. Basically, the distance within which an org must be befroe it can see (and thus use a fn on) its target
    this.targ = null; //stored as array pos of target
    this.isDef = 50;
    this.matureTime = orgStats[this.spec].timeToMature;
    this.mode = 'none';
    this.coolDown = 0; //set to 100 after pred or mate event. Forces org to wait before another 'activity'. when it reaches 0, choose mode pred or mode mate.
    this.lastMate = 0;
    this.mateTimerMax = orgStats[this.spec].gestation; //this will be made dynamic later (for R-selection vs. K-selection). It determines the period between matings (max)
    this.hunger = 0; //if this reaches 100, it no longer increases (can be lowered obvsly), but instead subtracts 0.5 from HP per turn (due to starvation)
};
orgConst.prototype.pred = function() {
    console.log('STUFF:', getDist(this, orgs[this.targ]), this.eats.indexOf(orgs[this.targ].spec));
    if (getDist(this, orgs[this.targ]) < this.vis && this.eats.indexOf(orgs[this.targ].spec) != -1 && this.hp) {
        //organism is close enough to target, and target is something that this org eats
        var rollChance = orgs[this.targ].isDef ? 10 : 3; //if target is being defended, only get a 1 in 10 chance. Otherwise, get a 1 in 3 chance.
        if (Math.floor(Math.random() * rollChance) < 1) {
            //kill!
            //first, grab the current HP of targ, and add to pred
            this.hp += orgs[this.targ].hp;
            if (this.hp > 100) {
                this.hp = 100;
            }
            console.log(this.spec, this.id, 'preyed on', orgs[this.targ].spec, orgs[this.targ].id, 'successfully!');
            orgs[this.targ].hp = 0; //set target hp to 0
        } else {
            //no kill! roll for pred dmg
            rollChance = orgs[this.targ].isDef ? 3 : 20; //if org is defended, 1 in 3 chance of injury. Else, 1 in 20.
            if (Math.floor(Math.random() * rollChance) < 1 && orgs[this.targ].type != 'prod') {
                //attack backfired! Remove 18pts of hp.
                //note that plants cannot defend
                this.hp -= 18;
            }
            console.log(this.spec, this.id, 'attempted to prey on', orgs[this.targ].spec, orgs[this.targ].id, 'but failed!');
        }
    }
    this.mode = 'none';
    this.coolDown = 100;
    this.pickNewTarg();
};
orgConst.prototype.mate = function() {
    if (Math.random() > 0.1 && getDist(this, orgs[this.targ]) < this.vis && this.hp && this.sex == 1 && orgs[this.targ].mode == 'mate' && orgs[this.targ].sex == 2 && orgs[this.targ].hp && orgs[this.targ].spec == this.spec) {
        //close enough, this and targ are alive, this and targ are same species, both are in mate mode, this is male, and targ is female
        //the math.rand part above introduces a random failure factor
        console.log(this.spec, this.id, 'mated with', orgs[this.targ].spec, orgs[this.targ].id);
        birth(this, orgs[this.targ]);
        return 'b';
    }
    this.mode = 'none';
    this.coolDown = 100;
    this.pickNewTarg();
};
orgConst.prototype.fight = function() {
    if (getDist(this, orgs[this.targ]) < this.vis && this.hp) {
        //organism is close enough to target, and is alive (hp>0)
        var rollChance = orgs[this.targ].spec == this.spec ? 15 : 3; //if targ is same species, low chance of dmg. Otherwise, slightly... less low
        var whichWins = Math.floor(Math.random() * 2);
        if (Math.floor(Math.random() * rollChance) < 1) {
            //fight results in an org being damaged 
            if (!whichWins) {
                //this org gets dmged
                console.log(this.spec, this.id, 'fought', orgs[this.targ].spec, orgs[this.targ].id, 'and lost.');
                this.hp -= 10;
            } else {
                //other org gets dmged
                console.log(this.spec, this.id, 'fought', orgs[this.targ].spec, orgs[this.targ].id, 'and won.');
                orgs[this.targ].hp -= 10;
            }
        } else {
            console.log('Fight between', this.spec, this.id, 'and', orgs[this.targ].spec, orgs[this.targ].id, 'with no injuries');
        }
    }
    this.mode = 'none';
    this.coolDown = 100;
    this.pickNewTarg();
};
orgConst.prototype.pickNewTarg = function() {
    //pick a target
    this.targ = Math.floor(Math.random() * orgs.length);
    var validMatch = false;
    var numTries=0;
    if (!orgs.length||orgs.length==1){
        this.targ==null;
        return false;
    }
    while (orgs[this.targ].id == this.id || (orgs[this.targ].type == 'prod' && this.type == 'carni') && validMatch) {
        //keep repicking until we have a legitimate match:
        //must not be the same organism (cannot target self), and predators do not interact with plants
        //note that we DONT need to check if the reverse is true (this is plant and target is pred), since plants dont have targets
        if (this.mode == 'pred' && this.eats.indexOf(orgs[this.targ].spec) != -1) {
            //valid prey item
            validMatch = true;
        } else if (this.mode != 'pred') {
            //mode not pred, so valid
            validMatch = true;
        }
        this.targ = Math.floor(Math.random() * orgs.length);
        numTries++;
        if (numTries>orgs.length-1){
            return false;
        }

    }
    console.log(this.spec, this.id, 'picked', orgs[this.targ].spec, orgs[this.targ].id);
};
orgConst.prototype.pickMode = function() {
    //this method picks the mode of the target, depending on how hungry the organism is and how recently its mated
    //hunger first:
    this.mode = 'wander'; //default to mode 'wander' if nothing else. In this mode, org seeks a random target to fight with it.
    if (!this.matureTime || this.matureTime < 1) {
        //make sure organism is sexually mature
        if ((this.hunger / 100) > (this.lastMate / this.mateTimerMax)) {
            if (Math.random() < this.hunger / 100) {
                //in other words, the hungrier this is, the more likely it is to pick pred mode
                this.mode = 'pred';
            } else if (Math.random() > (this.lastMate / this.mateTimerMax)) {
                this.mode = 'mate';
            }
        } else {
            //mate first
            if (Math.random() > (this.lastMate / this.mateTimerMax)) {
                //in other words, the hungrier this is, the more likely it is to pick pred mode
                this.mode = 'mate';
            } else if (Math.random() > this.hunger / 100) {
                this.mode = 'pred';
            }
        }
    } else if (Math.random() > this.hunger / 100) {
        this.mode = 'pred';
    }
};
var die = function(n) {
    //kill org. Remove from list of orgs (objs), and element from DOM. Also, run thur other orgs, left-shift ones AFTER this org, and redo targs (so no one is targetting an invalid targ)
    //this function is run for EVERY organism with hp <= 0 at every tick
    console.log(orgs[n], 'died!');
    var creature = orgs[n].sex==1?'male':'female';
    creature += ' '+orgs[n].spec+orgStats[orgs[n].spec].img;
    var theId = orgs[n].id;
    orgs.splice(n, 1);
    var orgDivs = $('.one-org');
    for (var r = 0; r < orgDivs.length; r++) {
        console.log('LOOKING TO DELETE', n);
        if (orgDivs[r].id == theId) {
            $(orgDivs[r]).remove();
            break;
        }
    }
    for (var i = 0; i < orgs.length; i++) {
        console.log('LOOKING TO DELETE', n);
        if (orgs[i].targ == n) {
            //if this organism's target was the old organism, give it a new target
            orgs[i].pickNewTarg();
        } else if (orgs[i].targ > n) {
            //if the number of this org is greater than the organism, left shift them by one (since we've removed one item from the list, it's 1 shorter)
            orgs[i].targ--;
        }
    }
    var scp = angular.element(document.querySelector('#angbit')).scope();
    scp.$apply(function(){
        scp.orgNum = orgs.length;
    });
    if(orgs.length<1){
        clearInterval(mainTimer);
        bootbox.alert('Your ecosystem has crashed! The last survivor was a '+creature+'.');
    }
};
var birth = function(f, m) {
    //make a new org from Father and Mother
    var zee = m ? f.z : h; //if mother is not defined, this is a plant, and thus 'lives' only on the bottom of the screen.
    var newBeast = new orgConst(f.x, f.y, zee, f.spec, f.type, Math.floor(Math.random() * 2) + 1);
    orgs.push(newBeast);
    var newOrgDiv = document.createElement('div');
    var gend = newBeast.sex == 1 ? '\u2642' : '\u2640';
    newOrgDiv.className = 'one-org';
    newOrgDiv.innerHTML = orgStats[newBeast.spec].img + gend;
    newOrgDiv.style.left = x + 'px';
    newOrgDiv.style.top = y + 'px';
    newOrgDiv.style.transform = 'translateZ(' + z + 'px)';
    newOrgDiv.id = newBeastie.id;
    $('#field').append(newOrgDiv);
    var scp = angular.element(document.querySelector('#angbit')).scope();
    scp.$apply(function(){
        scp.orgNum = orgs.length;
    })
};
//get dist btwn two orgs
var getDist = function(o, t) {
    var a = Math.abs(o.pos.x - t.pos.x);
    var b = Math.abs(o.pos.y - t.pos.y);
    var c = Math.abs(o.pos.z - t.pos.z);
    return Math.floor(Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2)));
};

//TESTING STUFF-------------
// var testP = new orgConst(2, 3, 4, 'monkey', 'omni', 1);
// var testH = new orgConst(3, 2, 4, 'mouse', 'omni', 1);
// testP.targ = 1;
// orgs.push(testP, testH);
// console.log(testP, testH);
//END TESTING STUFF---------

var step = function() {
    //MAIN STEPPER FUNCTION. AAAAAAAAAAAH;
    var numOrgs = orgs.length;
    for (var i = 0; i < numOrgs; i++) {
        //death
        if (orgs[i].hp < 1) {
            die(i);
            numOrgs--;
            i--;
            // continue;
        }
        //mode and target
        if (orgs[i].mode == 'none' && !orgs[i].coolDown && !orgs[i].matureTime) {
            orgs[i].pickMode();
            orgs[i].pickNewTarg();
        } else if (orgs[i].coolDown > 0 || orgs[i].matureTime > 0) {
            if (orgs[i].coolDown && orgs[i].coolDown > 0) {
                orgs[i].coolDown--;
            }
            if (orgs[i].matureTime && orgs[i].matureTime > 0) {
                orgs[i].matureTime--;
            }
        }
        //hunger and lastMate
        if (orgs[i].type!='prod'){
            if (orgs[i].hunger < 100) {
                orgs[i].hunger++;
            } else {
                //starvation!
                orgs[i].hp--;
            }
            if (orgs[i].lastMate < 100) {
                orgs[i].lastMate++;
            }
        }
        //movement!
        if (orgs[i].type != 'prod') {
            if (!orgs[i].targ || getDist(orgs[i], orgs[orgs[i].targ]) > orgs[i].vis) {
                //too far to fight/pred/mate, so move
                //first, check pos of target.
                if (orgs[i].targ) {
                    //has a target
                    if (orgs[i].pos.x > orgs[orgs[i].targ].pos.x) {
                        orgs[i].vel.dx = -1;
                    } else {
                        orgs[i].vel.dx = 1;
                    }

                    if (orgs[i].pos.y > orgs[orgs[i].targ].pos.y) {
                        orgs[i].vel.dy = -1;
                    } else {
                        orgs[i].vel.dy = 1;
                    }

                    if (orgs[i].pos.z > orgs[orgs[i].targ].pos.z) {
                        orgs[i].vel.dz = -1;
                    } else {
                        orgs[i].vel.dz = 1;
                    }
                }
                //next, boundaries
                if ((orgs[i].pos.x + orgs[i].vel.dx) > w || (orgs[i].pos.x + orgs[i].vel.dx) < 0) {
                    orgs[i].vel.dx = -1 * orgs[i].vel.dx;
                }

                if ((orgs[i].pos.y + orgs[i].vel.dy) > h || (orgs[i].pos.y + orgs[i].vel.dy) < 0) {
                    orgs[i].vel.dy = -1 * orgs[i].vel.dy;
                }

                if ((orgs[i].pos.z + orgs[i].vel.dz) > d || (orgs[i].pos.z + orgs[i].vel.dz) < 0) {
                    orgs[i].vel.dz = -1 * orgs[i].vel.dz;
                }
                orgs[i].pos.x += orgs[i].vel.dx;
                orgs[i].pos.y += orgs[i].vel.dy;
                orgs[i].pos.z += orgs[i].vel.dz;
                //now move the div!
                // console.log($('#'+orgs[i].id))
                $('#' + orgs[i].id).css({
                    'left': orgs[i].pos.x + 'px',
                    'top': orgs[i].pos.y + 'px',
                    'transform': 'translateZ(' + orgs[i].pos.z + 'px)'
                });
                // $('#'+orgs[i].id).html(JSON.stringify(orgs[i]))
            } else {
                //close enough for interaction
                if (orgs[i].mode == 'pred') {
                    orgs[i].pred();
                } else if (orgs[i].mode == 'mate') {
                    var sx = orgs[i].mate();
                    if (sx == 'b') {
                        numOrgs++;
                    }
                } else if (orgs[i].mode == 'wander' && orgs[orgs[i].targ].type != 'prod') {
                    orgs[i].fight();
                }
                //else near a plant, but not 'hungry', so pick new targ
                orgs[i].pickNewTarg();
            }
        } else if (Math.random() > 0.995) {
            //plants have their own behaviors, since they do not target and they do not mate.
            //note that we completely bypass the mating fn here.
            birth(orgs[i], null);
        }
    }
    itNum++;
    console.log(orgs[0].pos);
    // console.log('iteration number:', itNum,'world pop:',orgs.length);
};

var mainTimer; //main timer. Srsly, I'm not mincing variable names here, folks.

//first round is done with a timer to see how long it takes. this is used to prevent one 'round' from overtaking another (i.e., the functions for round 30 starting before the functions for round 29 are finished.)
var startMe = function() {
    var startTime = new Date().getTime();
    step();
    var endTime = new Date().getTime();
    timeDelta = (endTime - startTime) > 50 ? (endTime - startTime) : 50;
    console.log('frame rate: 1 frame every', timeDelta, 'ms.');
    mainTimer = setInterval(function() {
        step();
    }, timeDelta * 1.5);
};

var setupBox = function() {
    var v = 80;
    $('#b-left').css({
        'width': d + 'px',
        'height': h + 'px',
        'background-image': 'url("./img/skyside.jpg")',
        'background-size': '100% 100%',
        'transform': 'rotateY(90deg) translateZ(-' + (d / 2) + 'px) translateX(' + (d / 2) + 'px)'
    });
    $('#b-right').css({
        'width': d + 'px',
        'height': h + 'px',
        'background-image': 'url("./img/skyside.jpg")',
        'background-size': '100% 100%',
        'transform': 'rotateY(90deg) translateZ(' + (d / 2) + 'px) translateX(' + (d / 2) + 'px)'
    });
    $('#b-top').css({
        'width': w + 'px',
        'height': d + 'px',
        'background-image': 'url("./img/skytop.jpg")',
        'background-size': '100% 100%',
        'transform': 'rotateX(90deg) translateZ(' + (d / 2) + 'px) translateY(-' + (d / 2) + 'px)'
    });
    $('#b-back').css({
        'width': w + 'px',
        'height': h + 'px',
        'background-image': 'url("./img/skyside.jpg")',
        'background-size': '100% 100%',
        'transform': 'translateZ(-' + (d) + 'px)',
        'transform-style': 'preserve-3d'
    });
    $('#b-bottom').css({
        'width': w + 'px',
        'height': d + 'px',
        'background-image': 'url("./img/dirt.jpg")',
        'transform': 'rotateX(90deg) translateZ(' + (30) + 'px) translateY(-' + (d / 2) + 'px)',
        'overflow': 'hidden'
    });
    //now, the targetting cylinder
};
window.onkeyup = function(e) {
    //emergency stop button: press 's' to stop the iteration timer.
    if (e.which == 83) {
        clearInterval(mainTimer);
    }
};
setupBox();

var app = angular.module('pickerApp', []).controller('pik-cont', function($scope) {
    $scope.orgs = [];
    $scope.pikActive = true;
    $scope.orgNum = 0;
    for (var tax in orgStats) {
        var newOrg = {
            name: tax,
            img: orgStats[tax].img,
            gestation: orgStats[tax].gestation,
            timeToMature: orgStats[tax].timeToMature,
            type: orgStats[tax].type,
            eats: fl[tax] || 'prod',
            active: false,
            quant: 0,
            warns: {
                pairs: false,
                snaks: false
            }
        };
        $scope.orgs.push(newOrg);
    }
    $scope.checkOrgValid = function(o) {
        o.warns.pairs = false;
        o.warns.snaks = false;
        if (o.type == 'prod') {
            //plants dont have the pairs problem or the eating problem
            return false;
        } else {
            if (o.quant == 1) {
                o.warns.pairs = true;
            }
            //now check food orgs
            for (var t = 0; t < $scope.orgs.length; t++) {
                $scope.orgs[t].warns.snaks = true; //default to true until we turn it off
                if ($scope.orgs[t].type != 'prod' && $scope.orgs[t].quant > 0) {
                    for (var f = 0; f < $scope.orgs[t].eats.length; f++) {
                        for (var n = 0; n < $scope.orgs.length; n++) {
                            if ($scope.orgs[t].eats[f] == $scope.orgs[n].name && $scope.orgs[n].quant > 0) {
                                //found org this is supposed to eat
                                $scope.orgs[t].warns.snaks = false;
                            }
                        }
                    }
                } else if ($scope.orgs[t].quant < 1) {
                    $scope.orgs[t].warns.snaks = false;
                }
            }

        }
    };
    $scope.resetNums = function() {
        for (var t = 0; t < $scope.orgs.length; t++) {
            $scope.orgs[t].quant = 0;
            $scope.orgs[t].warns = {
                pairs: false,
                snaks: false
            };
        }
    };
    $scope.makeWorld = function() {
        var hasOrg = false;
        for (var t = 0; t < $scope.orgs.length; t++) {
            if ($scope.orgs[t].quant && $scope.orgs[t].quant > 1) {
                hasOrg = true;
                break;
            }
        }
        if (!hasOrg) {
            bootbox.confirm('Warning! Your world currently has zero organisms! Are you sure you still want to create it?', function(r) {
                if (r) {
                    $scope.populate();
                }
            });
        } else {
            $scope.populate();
        }
    };
    $scope.populate = function() {
        //and DOM said: let their be OBJS.
        //and He saw the Objs, and that they were truthy.
        for (var t = 0; t < $scope.orgs.length; t++) {
            for (var q = 0; q < $scope.orgs[t].quant; q++) {
                var x = Math.floor(Math.random() * w),
                    y = Math.floor(Math.random() * h),
                    z = Math.floor(Math.random() * d),
                    spec = $scope.orgs[t].name,
                    type = $scope.orgs[t].type,
                    sex = Math.floor(Math.random() * 2) + 1;
                var newBeastie = new orgConst(x, y, z, spec, type, sex);
                orgs.push(newBeastie);
                //now create the div el!
                var newOrgDiv = document.createElement('div');
                var gend = newBeastie.sex == 1 ? '\u2642' : '\u2640';
                newOrgDiv.className = 'one-org';
                newOrgDiv.innerHTML = $scope.orgs[t].img + gend;
                newOrgDiv.style.left = x + 'px';
                newOrgDiv.style.top = y + 'px';
                newOrgDiv.style.transform = 'translateZ(' + z + 'px)';
                newOrgDiv.id = newBeastie.id;
                $('#field').append(newOrgDiv);
                $scope.orgNum++
            }
        }
        console.log('ORGS', orgs);
        $scope.pikActive = false;
        if (orgs.length && orgs.length > 0) {
            startMe();
        } else {
            $scope.$digest();
        }
    };
});
app.filter('typeViewer', function() {
    var types = {
        'omni': 'Omnivore: Eats both plants an animals',
        'pred': 'Predator (carnivore): Eats animals',
        'herbi': 'Herbivore: Eats plants',
        'prod': 'Producer: Produces energy from sun'
    };
    return function(t) {
        return types[t];
    };
});